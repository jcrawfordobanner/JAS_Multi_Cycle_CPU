$date
	Mon Nov  4 03:15:30 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module IFUtestbench $end
$var wire 32 ! pcaddress [31:0] $end
$var wire 32 " Reg_31 [31:0] $end
$var reg 1 # Clk $end
$var reg 32 $ Reg_rs [31:0] $end
$var reg 1 % begintest $end
$var reg 1 & beq $end
$var reg 1 ' bne $end
$var reg 16 ( branchaddress [15:0] $end
$var reg 1 ) dutpassed $end
$var reg 1 * endtest $end
$var reg 1 + jump $end
$var reg 26 , jumpaddress [25:0] $end
$var reg 1 - regorimm $end
$var reg 1 . reset $end
$scope module dut $end
$var wire 32 / Reg_31 [31:0] $end
$var wire 32 0 Reg_rs [31:0] $end
$var wire 1 & beq $end
$var wire 1 ' bne $end
$var wire 16 1 branchaddress [15:0] $end
$var wire 1 # clk $end
$var wire 1 + jump $end
$var wire 26 2 jumpaddress [25:0] $end
$var wire 1 3 outputofor $end
$var wire 32 4 pcaddress [31:0] $end
$var wire 1 - regorimm $end
$var wire 1 . reset $end
$var wire 32 5 signextjumpaddr [31:0] $end
$var wire 32 6 signextbranchaddr [31:0] $end
$var wire 32 7 pctoalu [31:0] $end
$var wire 32 8 muxtopc [31:0] $end
$var wire 32 9 intoOGmux [31:0] $end
$var wire 32 : inputtopc [31:0] $end
$var wire 32 ; boutput [31:0] $end
$var wire 32 < beqbneadd [31:0] $end
$var wire 32 = alutomux [31:0] $end
$var reg 32 > fourinput [31:0] $end
$var reg 1 ? resetreg $end
$var reg 32 @ zeroinput [31:0] $end
$scope module addPCwithbranchadd $end
$var wire 32 A out [31:0] $end
$var wire 32 B in1 [31:0] $end
$var wire 32 C in0 [31:0] $end
$upscope $end
$scope module addwithPC $end
$var wire 32 D in0 [31:0] $end
$var wire 32 E out [31:0] $end
$var wire 32 F in1 [31:0] $end
$upscope $end
$scope module bnemulti $end
$var wire 1 3 address $end
$var wire 32 G input1 [31:0] $end
$var wire 32 H input0 [31:0] $end
$var reg 32 I out [31:0] $end
$upscope $end
$scope module jumpmulti $end
$var wire 1 + address $end
$var wire 32 J input0 [31:0] $end
$var wire 32 K input1 [31:0] $end
$var reg 32 L out [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 # clk $end
$var wire 32 M pctoalu [31:0] $end
$var wire 32 N muxtopc [31:0] $end
$var reg 32 O memory [31:0] $end
$upscope $end
$scope module regorimmmulti $end
$var wire 1 - address $end
$var wire 32 P input0 [31:0] $end
$var wire 32 Q input1 [31:0] $end
$var reg 32 R out [31:0] $end
$upscope $end
$scope module resetmulti $end
$var wire 1 ? address $end
$var wire 32 S input0 [31:0] $end
$var wire 32 T input1 [31:0] $end
$var reg 32 U out [31:0] $end
$upscope $end
$scope module signextendbranchaddress $end
$var wire 16 V in [15:0] $end
$var wire 32 W extended [31:0] $end
$upscope $end
$scope module signextendjumpaddress $end
$var wire 26 X in [25:0] $end
$var wire 32 Y extended [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b0xxxxxxxxxxxxxxxxxxxxxxxxxx Y
bx X
b0xxxxxxxxxxxxxxxx W
bx V
b0 U
b0 T
bx S
bx R
bx Q
bx P
b0 O
b0 N
b0 M
bx L
bx K
b100 J
bx I
b0xxxxxxxxxxxxxxxxxxxxxxxxxx H
bx G
b0 F
b100 E
b100 D
b0xxxxxxxxxxxxxxxx C
b100 B
bx A
b0 @
1?
b100 >
b100 =
bx <
bx ;
b0 :
bx 9
bx 8
b0 7
b0xxxxxxxxxxxxxxxx 6
b0xxxxxxxxxxxxxxxxxxxxxxxxxx 5
b0 4
x3
bx 2
bx 1
bx 0
b100 /
x.
x-
bx ,
x+
x*
x)
bx (
x'
x&
0%
bx $
x#
b100 "
b0 !
$end
#10
1)
0*
1%
#25
1.
0#
#30
1#
#35
b0 9
b0 K
b0 R
b100 :
b100 N
b100 U
b0 ;
b0 I
b0 P
b100 8
b100 L
b100 S
0?
03
b0 $
b0 0
b0 Q
0.
0-
0'
0&
0+
b100 <
b100 A
b100 G
b0 6
b0 C
b0 W
b0 (
b0 1
b0 V
b0 5
b0 H
b0 Y
b0 ,
b0 2
b0 X
0#
#40
b1000 :
b1000 N
b1000 U
b1000 8
b1000 L
b1000 S
b1000 <
b1000 A
b1000 G
b1000 "
b1000 /
b1000 =
b1000 B
b1000 E
b1000 J
b100 !
b100 4
b100 7
b100 F
b100 M
b100 O
1#
#45
b0 :
b0 N
b0 U
1?
1.
0#
#50
b100 8
b100 L
b100 S
b100 <
b100 A
b100 G
b100 "
b100 /
b100 =
b100 B
b100 E
b100 J
b0 !
b0 4
b0 7
b0 F
b0 M
b0 O
1#
#55
b10 9
b10 K
b10 R
b10 :
b10 N
b10 U
b10 8
b10 L
b10 S
b10 ;
b10 I
b10 P
0?
0.
1+
b10 5
b10 H
b10 Y
b10 ,
b10 2
b10 X
0#
#60
b110 <
b110 A
b110 G
b110 "
b110 /
b110 =
b110 B
b110 E
b110 J
b10 !
b10 4
b10 7
b10 F
b10 M
b10 O
1#
#65
b0 :
b0 N
b0 U
1?
1.
0#
#70
b100 <
b100 A
b100 G
b100 "
b100 /
b100 =
b100 B
b100 E
b100 J
b0 !
b0 4
b0 7
b0 F
b0 M
b0 O
1#
#75
0#
#80
b110 8
b110 L
b110 S
b110 9
b110 K
b110 R
b110 :
b110 N
b110 U
b110 ;
b110 I
b110 P
0?
0.
b110 5
b110 H
b110 Y
b110 ,
b110 2
b110 X
1#
#85
0#
#90
b1010 <
b1010 A
b1010 G
b1010 "
b1010 /
b1010 =
b1010 B
b1010 E
b1010 J
b110 !
b110 4
b110 7
b110 F
b110 M
b110 O
1#
#95
b0 :
b0 N
b0 U
1?
1.
0#
#100
b100 <
b100 A
b100 G
b100 "
b100 /
b100 =
b100 B
b100 E
b100 J
b0 !
b0 4
b0 7
b0 F
b0 M
b0 O
1#
#105
b11 8
b11 L
b11 S
b11 :
b11 N
b11 U
b11 9
b11 K
b11 R
b0 ;
b0 I
b0 P
0?
b11 $
b11 0
b11 Q
0.
1-
b0 5
b0 H
b0 Y
b0 ,
b0 2
b0 X
0#
#110
b111 <
b111 A
b111 G
b111 "
b111 /
b111 =
b111 B
b111 E
b111 J
b11 !
b11 4
b11 7
b11 F
b11 M
b11 O
1#
#115
b0 :
b0 N
b0 U
1?
1.
0#
#120
b100 <
b100 A
b100 G
b100 "
b100 /
b100 =
b100 B
b100 E
b100 J
b0 !
b0 4
b0 7
b0 F
b0 M
b0 O
1#
#125
b10011 8
b10011 L
b10011 S
b10011 :
b10011 N
b10011 U
b10011 9
b10011 K
b10011 R
b10011 ;
b10011 I
b10011 P
0?
13
b0 $
b0 0
b0 Q
0.
0-
1&
b10011 <
b10011 A
b10011 G
b1111 6
b1111 C
b1111 W
b1111 (
b1111 1
b1111 V
b10 5
b10 H
b10 Y
b10 ,
b10 2
b10 X
0#
#130
b100110 :
b100110 N
b100110 U
b100110 8
b100110 L
b100110 S
b100110 9
b100110 K
b100110 R
b100110 ;
b100110 I
b100110 P
b100110 <
b100110 A
b100110 G
b10111 "
b10111 /
b10111 =
b10111 B
b10111 E
b10111 J
b10011 !
b10011 4
b10011 7
b10011 F
b10011 M
b10011 O
1#
#135
b0 :
b0 N
b0 U
1?
1.
0#
#140
b10011 8
b10011 L
b10011 S
b10011 9
b10011 K
b10011 R
b10011 ;
b10011 I
b10011 P
b10011 <
b10011 A
b10011 G
b100 "
b100 /
b100 =
b100 B
b100 E
b100 J
b0 !
b0 4
b0 7
b0 F
b0 M
b0 O
1#
#145
b11000 8
b11000 L
b11000 S
b11000 9
b11000 K
b11000 R
b11000 :
b11000 N
b11000 U
b11000 ;
b11000 I
b11000 P
0?
0.
1'
0&
b11000 <
b11000 A
b11000 G
b10100 6
b10100 C
b10100 W
b10100 (
b10100 1
b10100 V
0#
#150
b110000 :
b110000 N
b110000 U
b110000 8
b110000 L
b110000 S
b110000 9
b110000 K
b110000 R
b110000 ;
b110000 I
b110000 P
b110000 <
b110000 A
b110000 G
b11100 "
b11100 /
b11100 =
b11100 B
b11100 E
b11100 J
b11000 !
b11000 4
b11000 7
b11000 F
b11000 M
b11000 O
1#
#155
0#
#160
1*
#5010
